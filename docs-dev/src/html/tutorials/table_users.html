<div class='container'>
<h1 id="table-users">Tutorial</h1>
<br>
<p>In this tutorial, we'll show how to create a web project using scaffolding and adding a new element. The element will render a table with user information that we have stored in a json file. This is a simple project so we won't be creating anything complicated for styling.</p>
<h2 id="1-new-project">1 New Project</h2>
<p>In order to start developing, we need RubyJS-Vite, so make sure you already have this tool since version 2.0.0. Using the 'scaffold' plugin, we will create a project called 'tutorial_table_users'. Make sure the default directory is set to the desktop. This is where the already created web project will be located.</p>
<p><em>Here is the overall command to set up the directory and create the web project:</em></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> ~/Desktop &amp;&amp;
rjsv scaffold web tutorial_table_users
</div></code></pre>
<p>After creation, the terminal tells us that the project is already created and we can access it in the directory and start the server. If we do so, the server starts and we get the url address where we can view the site. If you issue 'Hello RubyJS' on the site, then you have a properly working server with the RubyJS-Vite tool.</p>
<p><em>Here is the command to start the server:</em></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> tutorial_table_users &amp;&amp;
bin/server
</div></code></pre>
<h2 id="2-creating-an-element">2 Creating an Element</h2>
<p>We have already created a web project and we create a new element using the 'scaffold' plugin. This plugin takes an argument named 'element' and we type the name of the element as a parameter. We name the element 'table_users' and let it be created. Once created, the terminal will tell us that it has modified the files and the name of the element to use in the HTML syntax.</p>
<p><em>Here is the command to create the new element:</em></p>
<pre class="hljs"><code><div>rjsv scaffold element table_users
</div></code></pre>
<h3 id="21-importing-elements">2.1 Importing Elements</h3>
<p>In order for the server to recognize the created elements, it is necessary to import the library that initializes the elements. This is the 'elements.js.rb' file. This is done by opening the 'main.js.rb' file and writing the import of the required file here.</p>
<p><em>Here is an example script:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># src/rb/main.js.rb</span>

import <span class="hljs-string">'../css/style.css'</span>

import <span class="hljs-string">'./elements'</span>
<span class="hljs-comment">#...</span>
</div></code></pre>
<p>After inserting the import, save the file and the server will respond immediately. From now on we can insert elements in HTML syntax and they are non-binding.</p>
<h2 id="3-element-table-users">3 Element Table Users</h2>
<p>Now we need the element to be in HTML. We do this by using 'innerHTML' in the 'main.js.rb' file to insert the DOM tag 'elm-table-users'. This will run the script in 'elm_table_users.js.rb'. We will then modify the script to use a single method called 'init_elm()'. We need to have some user data. So we will create a file 'users.json' and put some data in it. We will open this data using import and convert it into HTML syntax. This will create a table, which we will further customize to a neater styling using a 'style.css' file.</p>
<h3 id="31-inner-html">3.1 Inner HTML</h3>
<p>So, first we edit the 'main.js.rb' file and insert the DOM label of our already created element into the innerHTML.</p>
<p><em>Here is the script of the solution:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># src/rb/main.js.rb</span>

<span class="hljs-comment">#...</span>
document.querySelector(<span class="hljs-string">'#app'</span>).innerHTML = <span class="hljs-string">"&lt;elm-table-users&gt;&lt;/elm-table-users&gt;"</span>
</div></code></pre>
<h3 id="32-json">3.2 Json</h3>
<p>Another thing needed for rendering data is a json file. Therefore, this will list the user content that will be put into the 'users.json' file. We then import it over the ElmTableUsers class to have this data present in the 'elm_table_users.js.rb' file.</p>
<h3 id="321-users-content">3.2.1 Users Content</h3>
<p>This dumped content is stored in the 'users.json' file. Therefore it is necessary to create the necessary folder or file.</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"users"</span>: [
    {
      <span class="hljs-attr">"company"</span>: <span class="hljs-string">"Alfreds Futterkiste"</span>,
      <span class="hljs-attr">"contact"</span>: <span class="hljs-string">"Maria Anders"</span>,
      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"Germany"</span>
    },
    {
      <span class="hljs-attr">"company"</span>: <span class="hljs-string">"Centro comercial Moctezuma"</span>,
      <span class="hljs-attr">"contact"</span>: <span class="hljs-string">"Francisco Chang"</span>,
      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"Mexico"</span>
    },
    {
      <span class="hljs-attr">"company"</span>: <span class="hljs-string">"Ernst Handel"</span>,
      <span class="hljs-attr">"contact"</span>: <span class="hljs-string">"Roland Mendel"</span>,
      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"Austria"</span>
    }
  ]
}
</div></code></pre>
<h3 id="322-import-content">3.2.2 Import Content</h3>
<p>Finally, we import the container so that the server recognizes that it is a JSON file. We do this by appending an extension after the file. We'll put the import in the 'elm_table_users.js.rb' file, so we need to modify it. We will wrap the import under the 'usersObj' name.</p>
<p><em>The modification should look like this:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># src/rb/elements/elm_table_users.js.rb</span>

import <span class="hljs-string">'usersObj'</span>, <span class="hljs-string">'../../json/users.json'</span>

export default <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElmTableUsers</span> &lt; HTMLElement</span>
<span class="hljs-comment">#...</span>
</div></code></pre>
<h3 id="33-init-element">3.3 Init Element</h3>
<p>In order to render everything, we need to modify the initialization of the element. Therefore, in the 'elm_table_users.js.rb' file we will modify the 'init_elm()' function and modify the variable to render the table. To make the table have some data, we will create an anonymous function that will create a nested element for the table.</p>
<h3 id="331-template">3.3.1 Template</h3>
<p>We'll start by preparing the temple. The template will contain a name and a table with three columns. The columns will have their own name and will not be empty.</p>
<p><em>The modification of the 'init_elm()' function will be as follows:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># src/rb/elements/elm_table_users.js.rb</span>

<span class="hljs-comment">#...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_elm</span><span class="hljs-params">()</span></span>
  template = <span class="hljs-string">""</span><span class="hljs-string">"
  &lt;h1&gt;Users&lt;/h1&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th&gt;Company&lt;/th&gt;
      &lt;th&gt;Contact&lt;/th&gt;
      &lt;th&gt;Country&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  "</span><span class="hljs-string">""</span>

  <span class="hljs-keyword">self</span>.innerHTML = template
<span class="hljs-keyword">end</span>
<span class="hljs-comment">#...</span>
</div></code></pre>
<h3 id="332-anonymous-function">3.3.2 Anonymous Function</h3>
<p>To insert data from the 'users.json' file, we open its container and start exploring the users. The exploration is done via a loop, which gives us one user and we can manipulate their data. So we'll put them into a template that is designed to nest the information for that column separately. The anonymous function will return HTML content with the elements already prepared. This anonymous function, needs to be called inside the base templates and under 'tr' markup which has column names inside. All of the above is again modified in the 'init_elm()' function.</p>
<p><em>Another modification of the 'init_elm()' function:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># src/rb/elements/elm_table_users.js.rb</span>

<span class="hljs-comment">#...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_elm</span><span class="hljs-params">()</span></span>
  l_tr_users = lambda <span class="hljs-keyword">do</span>
    dom_elements = []
    users_obj.users.each <span class="hljs-keyword">do</span> <span class="hljs-params">|user|</span>
      template = <span class="hljs-string">""</span><span class="hljs-string">"
      &lt;tr&gt;
        &lt;td&gt;<span class="hljs-subst">#{user.company}</span>&lt;/td&gt;
        &lt;td&gt;<span class="hljs-subst">#{user.contact}</span>&lt;/td&gt;
        &lt;td&gt;<span class="hljs-subst">#{user.country}</span>&lt;/td&gt;
      &lt;/tr&gt;
      "</span><span class="hljs-string">""</span>
      dom_elements &lt;&lt; template
    <span class="hljs-keyword">end</span>
    dom_elements.join(<span class="hljs-string">"\n"</span>)
  <span class="hljs-keyword">end</span>

  template = <span class="hljs-string">""</span><span class="hljs-string">"
  &lt;h1&gt;Users&lt;/h1&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th&gt;Company&lt;/th&gt;
      &lt;th&gt;Contact&lt;/th&gt;
      &lt;th&gt;Country&lt;/th&gt;
    &lt;/tr&gt;
    <span class="hljs-subst">#{l_tr_users()}</span>
  &lt;/table&gt;
  "</span><span class="hljs-string">""</span>

  <span class="hljs-keyword">self</span>.innerHTML = template
<span class="hljs-keyword">end</span>
<span class="hljs-comment">#...</span>
</div></code></pre>
<h3 id="34-stylization">3.4 Stylization</h3>
<p>If you have the server turned on and you are viewing a web project in the browser, you can see the organized data with the users. There is no stylization that would be clearer. We can solve this problem simply by modifying the 'style.css' file and adding values for table, td, th and tr.</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* src/css/style.css */</span>

<span class="hljs-selector-tag">table</span> {
  <span class="hljs-attribute">font-family</span>: arial, sans-serif;
  <span class="hljs-attribute">border-collapse</span>: collapse;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
}

<span class="hljs-selector-tag">td</span>, <span class="hljs-selector-tag">th</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#bababa</span>;
  <span class="hljs-attribute">text-align</span>: left;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>;
}

<span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-child(even)</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dddddd</span>;
}
</div></code></pre>
<h2 id="4-conclusion">4 Conclusion</h2>
<p>If we save the css file, we can see the change immediately and we can see a neater stylization of the table. If any file is changed (if it is imported), the server records the change and restarts the server immediately. This is a quick moment that we don't even notice that the server has restarted. Which is a big advantage for web project development.</p>
<p>RubyJS-Vite is a tool that communicates well with the Vite tool and in real time. The magic is that when the server is turned on, RubyJS-Vite is turned on after the fact and recognizes all file event activity in the defined path where the RB files are stored. If there is an event then RubyJS transforms the script into a JS file and the Vite tool, recognizes any files with JS syntax and it communicates with the server.</p>
<p>As far as the 'scaffold' plugin is concerned, it should assist in faster project development. We tried out how to create an element in that tutorial and didn't have to go round a new round by not having to write all the script that keeps repeating if we want to have multiple elements in a web project.</p>

</div>