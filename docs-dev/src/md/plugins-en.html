<!DOCTYPE html>
<html>
<head>
<title>plugins-en.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="plugins">Plugins</h1>
<p>It is an extension element of the CLI application. If a plugin is inserted into the root project, RubyJS will recognize the existence of the plugin in the 'plugins' folder. Everything is triggered with the 'rjsv' command and the plugin name. If we are not sure what the name of the plugin is, it is recommended to use the help command. This will print out all the arguments to the application itself with and plugins.</p>
<p><em>Here is the command to display the help:</em></p>
<pre class="hljs"><code><div>rjsv -h
</div></code></pre>
<h2 id="1-location">1 Location</h2>
<p>As I mentioned before, the plugin is placed in the 'plugins' folder, which is located in the root folder of the project. Anything that can run a RubyJS application is taken as a project. As a RubyJS-Vite project itself, it already has its own plugin called 'scaffold'. So, it can be used all the time where it is needed.</p>
<p><em>As an example, here I will give a tree structure of folders:</em></p>
<pre class="hljs"><code><div>A
└── plugins
    ├── markdown
    └── vue
B
└── plugins
    ├── docs
    └── react
</div></code></pre>
<blockquote>
<h3 id="info">Info</h3>
<p>Plugins are relative to projects. If project A has a specific plugin, you won't see that plugin in project B.</p>
</blockquote>
<h3 id="11-home-directory-for-easy-access">1.1 Home directory for easy access</h3>
<p>There is another way to extend plugins using the home directory. Just create a new hidden file called '.rjsv/plugins' in your home directory. Then our program will automatically recognize it and allow you to use plugins in all projects created with RubyJS tool.</p>
<p><em>Here is an example of a home directory:</em></p>
<pre class="hljs"><code><div><span class="hljs-variable">$HOME</span>/.rjsv/plugins
</div></code></pre>
<h2 id="2-development">2 Development</h2>
<p>If you are developing a project with RubyJS and you need to change the way functions work, you need to create a specific plugin. To create a plugin, we need to know a few criteria to be able to initialize it in the CLI of the application. If these criteria are met and the specific plugin can initialize, then we can write the function logic.</p>
<blockquote>
<h3 id="info">Info</h3>
<p>Here it should be emphasized that we can use the API Reference to manipulate an existing function. Most functions are independent and reusable.</p>
</blockquote>
<h3 id="21-criteria">2.1 Criteria</h3>
<p><em>Here is a list of criteria to be followed:</em></p>
<ol>
<li>Structure the folders so that everything is under the plugin name in the 'lib' folder.</li>
<li>Initialization is done in the 'init.rb' file. In it, the class 'Init' is written, which inherits the ready abstract class 'RSJV::Plugin'.</li>
<li>The 'Init' class is nested in modules to indicate that it is a plugin with that name.</li>
<li>The 'Init' class is taken as a representative content snippet of the plugin. Imported scripts are to be written here, and abstract functions are to be wrapped to run functions from different libraries (there should be no logic here).</li>
<li>The name of the plugin is automatically written according to the name of the module, which should be the third nested one.</li>
</ol>
<p>I have described 5 criteria to follow when creating your own plugin. In order to understand it better, I will elaborate on each criterion separately.</p>
<h3 id="211-folder-structure">2.1.1 Folder Structure</h3>
<p>A folder structure is needed to better organize libraries. Therefore it is essential to make sure that the plugin itself is in the plugins folder and then in a folder under its own name. It should have a libraries folder and an initialization file in it. RubyJS recognizes this structuring and knows in advance that it will find there all the important information or functions to be run.</p>
<p><em>Here is an example of the tree structure:</em></p>
<pre class="hljs"><code><div>.
└── plugins
    └── &lt;plugin name&gt;
        └── lib
            └── init.rb
</div></code></pre>
<h3 id="212-initialization-file">2.1.2 Initialization File</h3>
<p>Initialization is done in the 'init.rb' file. In it, the class 'Init' is written, which inherits the ready abstract class <a href="#1-7-lib/rjsv/plugin">RSJV::Plugin</a>. You need to know this abstract class, mainly because of the abstract methods. The methods should be defined in the class and populated.</p>
<p><em>It is these abstract methods:</em></p>
<ul>
<li><strong>description</strong> - a short description of the plugin, which will be printed during help.</li>
<li><strong>arguments</strong> - initialization of arguments if the plugin is running.</li>
<li><strong>init</strong> - initialization method that starts the logic of the plugin functions. It is similar to a method like main().</li>
</ul>
<p><em>Here is a sample of the listed class:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># lib/init.rb</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Init</span> &lt; RJSV::Plugin</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">description</span></span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arguments</span></span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<h3 id="213-nesting-modules">2.1.3 Nesting Modules</h3>
<p>You need to pay attention to the structure of the modules when creating a plugin. In order for RubyJS to recognize a custom plugin, it looks for all classes in the RJSV::Plugins module. If they are not there, it cannot recognize that it is a plugin.</p>
<p><em>Therefore, the initialization file should look similar:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># lib/init.rb</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">RJSV</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Plugins</span></span>
    <span class="hljs-class"><span class="hljs-keyword">module</span> &lt;PluginName&gt;</span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Init</span> &lt; RJSV::Plugin</span>
        <span class="hljs-comment"># ...</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<blockquote>
<h3 id="info">Info</h3>
<p>When creating plugin libraries, the structure of the modules should also be followed. If it is not followed, there is a possible conflict of functions from different plugins or separate RubyJS applications.</p>
</blockquote>
<h3 id="214-representative-content-snippet">2.1.4 Representative Content Snippet</h3>
<p>Simply put, an initialization file is like the contents of a book. If we open this file, we can see everything the plugin contains and what functions it runs when it initializes.</p>
<p><em>Here is an example of what an initialization file should look like, for the scaffold plugin:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># lib/init.rb</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">RJSV</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Plugins</span></span>
    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Scaffold</span></span>
      require_relative <span class="hljs-string">'./scaffold/cli/arguments'</span>

      require_relative <span class="hljs-string">'./scaffold/vite'</span>
      require_relative <span class="hljs-string">'./scaffold/states'</span>
      require_relative <span class="hljs-string">'./scaffold/create'</span>

      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Init</span> &lt; RJSV::Plugin</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
          @arguments_cli = RJSV::Plugins::Scaffold::CLI::Arguments
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">description</span></span>
          <span class="hljs-string">"Scaffolding can create new\n"</span> +
          <span class="hljs-string">"projects or create new elements."</span>
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arguments</span></span>
          @arguments_cli.init(<span class="hljs-keyword">self</span>)
        <span class="hljs-keyword">end</span>

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>
          Scaffold::States.create_web_state(@arguments_cli.options)
          Scaffold::States.create_element_state(@arguments_cli.options)
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<h3 id="215-plugin-name">2.1.5 Plugin Name</h3>
<p>The plugin name is automatically written from the third module. Therefore it is important to have the third module written. So the 'RJSV::Plugin.name()' method is not abstract, but it can be overloaded. Overloading this function is rare, but possible if we want to have a specific plugin name.</p>
<p><em>Here is a sample name of the third plugin:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># lib/init.rb</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">RJSV</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Plugins</span></span>
    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Scaffold</span>  <span class="hljs-comment"># This is the 'scaffold' plugin name.</span></span>
    <span class="hljs-comment">#...</span>
</div></code></pre>
<p><em>Or here is an example of overloading the 'name()' method, which shortens the plugin name:</em></p>
<pre class="hljs"><code><div><span class="hljs-comment"># lib/init.rb</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">RJSV</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Plugins</span></span>
    <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Scaffold</span></span>
      <span class="hljs-comment">#...</span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Init</span> &lt; RJSV::Plugin</span>
        <span class="hljs-comment">#...</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span></span>
          <span class="hljs-string">'scaf'</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-comment">#...</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</div></code></pre>
<h3 id="22-logic-of-functions">2.2 Logic of Functions</h3>
<p>Function logic should be split into libraries and should not be in the initialization file itself. When writing functions, we can use predefined functions in the RJSV module. It's a good idea to read the API Reference, which breaks down the module or function classes. If we use a function from the RJSV module, it is recommended to write the whole path to the function.</p>

</body>
</html>
